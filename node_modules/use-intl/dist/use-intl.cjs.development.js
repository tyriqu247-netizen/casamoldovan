'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var IntlMessageFormat = require('intl-messageformat');
var React = require('react');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var IntlMessageFormat__default = /*#__PURE__*/_interopDefaultLegacy(IntlMessageFormat);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

exports.IntlErrorCode = void 0;
(function (IntlErrorCode) {
  IntlErrorCode["MISSING_MESSAGE"] = "MISSING_MESSAGE";
  IntlErrorCode["MISSING_FORMAT"] = "MISSING_FORMAT";
  IntlErrorCode["ENVIRONMENT_FALLBACK"] = "ENVIRONMENT_FALLBACK";
  IntlErrorCode["INSUFFICIENT_PATH"] = "INSUFFICIENT_PATH";
  IntlErrorCode["INVALID_MESSAGE"] = "INVALID_MESSAGE";
  IntlErrorCode["INVALID_KEY"] = "INVALID_KEY";
  IntlErrorCode["FORMATTING_ERROR"] = "FORMATTING_ERROR";
})(exports.IntlErrorCode || (exports.IntlErrorCode = {}));
var IntlError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(IntlError, _Error);
  function IntlError(code, originalMessage) {
    var _this;
    var message = code;
    if (originalMessage) {
      message += ': ' + originalMessage;
    }
    _this = _Error.call(this, message) || this;
    _this.code = void 0;
    _this.originalMessage = void 0;
    _this.code = code;
    if (originalMessage) {
      _this.originalMessage = originalMessage;
    }
    return _this;
  }
  return IntlError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

function setTimeZoneInFormats(formats, timeZone) {
  if (!formats) return formats;
  // The only way to set a time zone with `intl-messageformat` is to merge it into the formats
  // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15
  return Object.keys(formats).reduce(function (acc, key) {
    acc[key] = _extends({
      timeZone: timeZone
    }, formats[key]);
    return acc;
  }, {});
}
/**
 * `intl-messageformat` uses separate keys for `date` and `time`, but there's
 * only one native API: `Intl.DateTimeFormat`. Additionally you might want to
 * include both a time and a date in a value, therefore the separation doesn't
 * seem so useful. We offer a single `dateTime` namespace instead, but we have
 * to convert the format before `intl-messageformat` can be used.
 */
function convertFormatsToIntlMessageFormat(formats, timeZone) {
  var formatsWithTimeZone = timeZone ? _extends({}, formats, {
    dateTime: setTimeZoneInFormats(formats.dateTime, timeZone)
  }) : formats;
  var mfDateDefaults = IntlMessageFormat__default["default"].formats.date;
  var defaultDateFormats = timeZone ? setTimeZoneInFormats(mfDateDefaults, timeZone) : mfDateDefaults;
  var mfTimeDefaults = IntlMessageFormat__default["default"].formats.time;
  var defaultTimeFormats = timeZone ? setTimeZoneInFormats(mfTimeDefaults, timeZone) : mfTimeDefaults;
  return _extends({}, formatsWithTimeZone, {
    date: _extends({}, defaultDateFormats, formatsWithTimeZone == null ? void 0 : formatsWithTimeZone.dateTime),
    time: _extends({}, defaultTimeFormats, formatsWithTimeZone == null ? void 0 : formatsWithTimeZone.dateTime)
  });
}

/**
 * Contains defaults that are used for all entry points into the core.
 * See also `InitializedIntlConfiguration`.
 */
function defaultGetMessageFallback(props) {
  return [props.namespace, props.key].filter(function (part) {
    return part != null;
  }).join('.');
}
function defaultOnError(error) {
  console.error(error);
}

function resolvePath(messages, key, namespace) {
  if (!messages) {
    throw new Error("No messages available at `" + namespace + "`." );
  }
  var message = messages;
  key.split('.').forEach(function (part) {
    var next = message[part];
    if (part == null || next == null) {
      throw new Error("Could not resolve `" + key + "` in " + (namespace ? "`" + namespace + "`" : 'messages') + "." );
    }
    message = next;
  });
  return message;
}
function prepareTranslationValues(values) {
  if (Object.keys(values).length === 0) return undefined;
  // Workaround for https://github.com/formatjs/formatjs/issues/1467
  var transformedValues = {};
  Object.keys(values).forEach(function (key) {
    var index = 0;
    var value = values[key];
    var transformed;
    if (typeof value === 'function') {
      transformed = function transformed(chunks) {
        var result = value(chunks);
        return React.isValidElement(result) ? React.cloneElement(result, {
          key: key + index++
        }) : result;
      };
    } else {
      transformed = value;
    }
    transformedValues[key] = transformed;
  });
  return transformedValues;
}
function getMessagesOrError(_ref) {
  var messages = _ref.messages,
    namespace = _ref.namespace,
    _ref$onError = _ref.onError,
    onError = _ref$onError === void 0 ? defaultOnError : _ref$onError;
  try {
    if (!messages) {
      throw new Error("development" !== 'production' ? "No messages were configured on the provider." : undefined);
    }
    var retrievedMessages = namespace ? resolvePath(messages, namespace) : messages;
    if (!retrievedMessages) {
      throw new Error("development" !== 'production' ? "No messages for namespace `" + namespace + "` found." : undefined);
    }
    return retrievedMessages;
  } catch (error) {
    var intlError = new IntlError(exports.IntlErrorCode.MISSING_MESSAGE, error.message);
    onError(intlError);
    return intlError;
  }
}
function getPlainMessage(candidate, values) {
  if (values) return undefined;
  var unescapedMessage = candidate.replace(/'([{}])/gi, '$1');
  // Placeholders can be in the message if there are default values,
  // or if the user has forgotten to provide values. In the latter
  // case we need to compile the message to receive an error.
  var hasPlaceholders = /<|{/.test(unescapedMessage);
  if (!hasPlaceholders) {
    return unescapedMessage;
  }
  return undefined;
}
function createBaseTranslator(_ref2) {
  var defaultTranslationValues = _ref2.defaultTranslationValues,
    globalFormats = _ref2.formats,
    _ref2$getMessageFallb = _ref2.getMessageFallback,
    getMessageFallback = _ref2$getMessageFallb === void 0 ? defaultGetMessageFallback : _ref2$getMessageFallb,
    locale = _ref2.locale,
    messageFormatCache = _ref2.messageFormatCache,
    messagesOrError = _ref2.messagesOrError,
    namespace = _ref2.namespace,
    onError = _ref2.onError,
    timeZone = _ref2.timeZone;
  function getFallbackFromErrorAndNotify(key, code, message) {
    var error = new IntlError(code, message);
    onError(error);
    return getMessageFallback({
      error: error,
      key: key,
      namespace: namespace
    });
  }
  function translateBaseFn( /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */
  key, /** Key value pairs for values to interpolate into the message. */
  values, /** Provide custom formats for numbers, dates and times. */
  formats) {
    if (messagesOrError instanceof IntlError) {
      // We have already warned about this during render
      return getMessageFallback({
        error: messagesOrError,
        key: key,
        namespace: namespace
      });
    }
    var messages = messagesOrError;
    var message;
    try {
      message = resolvePath(messages, key, namespace);
    } catch (error) {
      return getFallbackFromErrorAndNotify(key, exports.IntlErrorCode.MISSING_MESSAGE, error.message);
    }
    function joinPath(parts) {
      return parts.filter(function (part) {
        return part != null;
      }).join('.');
    }
    var cacheKey = joinPath([locale, namespace, key, String(message)]);
    var messageFormat;
    if (messageFormatCache != null && messageFormatCache.has(cacheKey)) {
      messageFormat = messageFormatCache.get(cacheKey);
    } else {
      if (typeof message === 'object') {
        var code, errorMessage;
        if (Array.isArray(message)) {
          code = exports.IntlErrorCode.INVALID_MESSAGE;
          {
            errorMessage = "Message at `" + joinPath([namespace, key]) + "` resolved to an array, but only strings are supported. See https://next-intl-docs.vercel.app/docs/usage/messages#arrays-of-messages";
          }
        } else {
          code = exports.IntlErrorCode.INSUFFICIENT_PATH;
          {
            errorMessage = "Message at `" + joinPath([namespace, key]) + "` resolved to an object, but only strings are supported. Use a `.` to retrieve nested messages. See https://next-intl-docs.vercel.app/docs/usage/messages#structuring-messages";
          }
        }
        return getFallbackFromErrorAndNotify(key, code, errorMessage);
      }
      // Hot path that avoids creating an `IntlMessageFormat` instance
      var plainMessage = getPlainMessage(message, values);
      if (plainMessage) return plainMessage;
      try {
        messageFormat = new IntlMessageFormat__default["default"](message, locale, convertFormatsToIntlMessageFormat(_extends({}, globalFormats, formats), timeZone));
      } catch (error) {
        return getFallbackFromErrorAndNotify(key, exports.IntlErrorCode.INVALID_MESSAGE, error.message);
      }
      messageFormatCache == null || messageFormatCache.set(cacheKey, messageFormat);
    }
    try {
      var formattedMessage = messageFormat.format(
      // @ts-ignore `intl-messageformat` expects a different format
      // for rich text elements since a recent minor update. This
      // needs to be evaluated in detail, possibly also in regards
      // to be able to format to parts.
      prepareTranslationValues(_extends({}, defaultTranslationValues, values)));
      if (formattedMessage == null) {
        throw new Error("development" !== 'production' ? "Unable to format `" + key + "` in " + (namespace ? "namespace `" + namespace + "`" : 'messages') : undefined);
      }
      // Limit the function signature to return strings or React elements
      return React.isValidElement(formattedMessage) ||
      // Arrays of React elements
      Array.isArray(formattedMessage) || typeof formattedMessage === 'string' ? formattedMessage : String(formattedMessage);
    } catch (error) {
      return getFallbackFromErrorAndNotify(key, exports.IntlErrorCode.FORMATTING_ERROR, error.message);
    }
  }
  function translateFn( /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */
  key, /** Key value pairs for values to interpolate into the message. */
  values, /** Provide custom formats for numbers, dates and times. */
  formats) {
    var result = translateBaseFn(key, values, formats);
    if (typeof result !== 'string') {
      return getFallbackFromErrorAndNotify(key, exports.IntlErrorCode.INVALID_MESSAGE, "The message `" + key + "` in " + (namespace ? "namespace `" + namespace + "`" : 'messages') + " didn't resolve to a string. If you want to format rich text, use `t.rich` instead." );
    }
    return result;
  }
  translateFn.rich = translateBaseFn;
  translateFn.raw = function ( /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */
  key) {
    if (messagesOrError instanceof IntlError) {
      // We have already warned about this during render
      return getMessageFallback({
        error: messagesOrError,
        key: key,
        namespace: namespace
      });
    }
    var messages = messagesOrError;
    try {
      return resolvePath(messages, key, namespace);
    } catch (error) {
      return getFallbackFromErrorAndNotify(key, exports.IntlErrorCode.MISSING_MESSAGE, error.message);
    }
  };
  return translateFn;
}

/**
 * For the strictly typed messages to work we have to wrap the namespace into
 * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045
 */
function resolveNamespace(namespace, namespacePrefix) {
  return namespace === namespacePrefix ? undefined : namespace.slice((namespacePrefix + '.').length);
}

var _excluded$3 = ["getMessageFallback", "messages", "namespace", "onError"];
function createTranslatorImpl(_ref, namespacePrefix) {
  var getMessageFallback = _ref.getMessageFallback,
    messages = _ref.messages,
    namespace = _ref.namespace,
    onError = _ref.onError,
    rest = _objectWithoutPropertiesLoose(_ref, _excluded$3);
  // The `namespacePrefix` is part of the type system.
  // See the comment in the function invocation.
  messages = messages[namespacePrefix];
  namespace = resolveNamespace(namespace, namespacePrefix);
  var translator = createBaseTranslator(_extends({}, rest, {
    onError: onError,
    getMessageFallback: getMessageFallback,
    messagesOrError: getMessagesOrError({
      messages: messages,
      namespace: namespace,
      onError: onError
    })
  }));
  var originalRich = translator.rich;
  function base() {
    return translator.apply(void 0, arguments);
  }
  // Augment `t.rich` to return plain strings
  base.rich = function (key, /** Key value pairs for values to interpolate into the message. */
  values, formats) {
    // `chunks` is returned as a string when no React element
    // is used, therefore it's safe to cast this type.
    var result = originalRich(key, values, formats);
    // When only string chunks are provided to the parser, only strings should be returned here.
    if (typeof result !== 'string') {
      var error = new IntlError(exports.IntlErrorCode.FORMATTING_ERROR, "`createTranslator` only accepts functions for rich text formatting that receive and return strings.\n\nE.g. t.rich('rich', {b: (chunks) => `<b>${chunks}</b>`})" );
      onError(error);
      return getMessageFallback({
        error: error,
        key: key,
        namespace: namespace
      });
    }
    return result;
  };
  base.raw = translator.raw;
  return base;
}

var _excluded$2 = ["getMessageFallback", "messages", "namespace", "onError"];
/**
 * Translates messages from the given namespace by using the ICU syntax.
 * See https://formatjs.io/docs/core-concepts/icu-syntax.
 *
 * If no namespace is provided, all available messages are returned.
 * The namespace can also indicate nesting by using a dot
 * (e.g. `namespace.Component`).
 */
function createTranslator(_ref) {
  var _ref$getMessageFallba = _ref.getMessageFallback,
    getMessageFallback = _ref$getMessageFallba === void 0 ? defaultGetMessageFallback : _ref$getMessageFallba,
    messages = _ref.messages,
    namespace = _ref.namespace,
    _ref$onError = _ref.onError,
    onError = _ref$onError === void 0 ? defaultOnError : _ref$onError,
    rest = _objectWithoutPropertiesLoose(_ref, _excluded$2);
  // We have to wrap the actual function so the type inference for the optional
  // namespace works correctly. See https://stackoverflow.com/a/71529575/343045
  // The prefix ("!") is arbitrary.
  return createTranslatorImpl(_extends({}, rest, {
    onError: onError,
    getMessageFallback: getMessageFallback,
    messages: {
      '!': messages
    },
    namespace: namespace ? "!." + namespace : '!'
  }), '!');
}

var SECOND = 1;
var MINUTE = SECOND * 60;
var HOUR = MINUTE * 60;
var DAY = HOUR * 24;
var WEEK = DAY * 7;
var MONTH = DAY * (365 / 12); // Approximation
var QUARTER = MONTH * 3;
var YEAR = DAY * 365;
var UNIT_SECONDS = {
  second: SECOND,
  seconds: SECOND,
  minute: MINUTE,
  minutes: MINUTE,
  hour: HOUR,
  hours: HOUR,
  day: DAY,
  days: DAY,
  week: WEEK,
  weeks: WEEK,
  month: MONTH,
  months: MONTH,
  quarter: QUARTER,
  quarters: QUARTER,
  year: YEAR,
  years: YEAR
};
function resolveRelativeTimeUnit(seconds) {
  var absValue = Math.abs(seconds);
  if (absValue < MINUTE) {
    return 'second';
  } else if (absValue < HOUR) {
    return 'minute';
  } else if (absValue < DAY) {
    return 'hour';
  } else if (absValue < WEEK) {
    return 'day';
  } else if (absValue < MONTH) {
    return 'week';
  } else if (absValue < YEAR) {
    return 'month';
  }
  return 'year';
}
function calculateRelativeTimeValue(seconds, unit) {
  // We have to round the resulting values, as `Intl.RelativeTimeFormat`
  // will include fractions like '2.1 hours ago'.
  return Math.round(seconds / UNIT_SECONDS[unit]);
}
function createFormatter(_ref) {
  var formats = _ref.formats,
    locale = _ref.locale,
    globalNow = _ref.now,
    _ref$onError = _ref.onError,
    onError = _ref$onError === void 0 ? defaultOnError : _ref$onError,
    globalTimeZone = _ref.timeZone;
  function resolveFormatOrOptions(typeFormats, formatOrOptions) {
    var options;
    if (typeof formatOrOptions === 'string') {
      var formatName = formatOrOptions;
      options = typeFormats == null ? void 0 : typeFormats[formatName];
      if (!options) {
        var error = new IntlError(exports.IntlErrorCode.MISSING_FORMAT, "Format `" + formatName + "` is not available. You can configure it on the provider or provide custom options." );
        onError(error);
        throw error;
      }
    } else {
      options = formatOrOptions;
    }
    return options;
  }
  function getFormattedValue(value, formatOrOptions, typeFormats, formatter) {
    var options;
    try {
      options = resolveFormatOrOptions(typeFormats, formatOrOptions);
    } catch (error) {
      return String(value);
    }
    try {
      return formatter(options);
    } catch (error) {
      onError(new IntlError(exports.IntlErrorCode.FORMATTING_ERROR, error.message));
      return String(value);
    }
  }
  function dateTime( /** If a number is supplied, this is interpreted as a UTC timestamp. */
  value,
  /** If a time zone is supplied, the `value` is converted to that time zone.
   * Otherwise the user time zone will be used. */
  formatOrOptions) {
    return getFormattedValue(value, formatOrOptions, formats == null ? void 0 : formats.dateTime, function (options) {
      var _options;
      if (!((_options = options) != null && _options.timeZone)) {
        if (globalTimeZone) {
          options = _extends({}, options, {
            timeZone: globalTimeZone
          });
        } else {
          onError(new IntlError(exports.IntlErrorCode.ENVIRONMENT_FALLBACK, "development" !== 'production' ? "The `timeZone` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl-docs.vercel.app/docs/configuration#time-zone" : undefined));
        }
      }
      return new Intl.DateTimeFormat(locale, options).format(value);
    });
  }
  function number(value, formatOrOptions) {
    return getFormattedValue(value, formatOrOptions, formats == null ? void 0 : formats.number, function (options) {
      return new Intl.NumberFormat(locale, options).format(value);
    });
  }
  function getGlobalNow() {
    if (globalNow) {
      return globalNow;
    } else {
      onError(new IntlError(exports.IntlErrorCode.ENVIRONMENT_FALLBACK, "The `now` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl-docs.vercel.app/docs/configuration#now" ));
      return new Date();
    }
  }
  function extractNowDate(nowOrOptions) {
    if (nowOrOptions instanceof Date || typeof nowOrOptions === 'number') {
      return new Date(nowOrOptions);
    }
    if ((nowOrOptions == null ? void 0 : nowOrOptions.now) !== undefined) {
      return new Date(nowOrOptions.now);
    }
    return getGlobalNow();
  }
  function relativeTime( /** The date time that needs to be formatted. */
  date, /** The reference point in time to which `date` will be formatted in relation to.  */
  nowOrOptions) {
    try {
      var dateDate = new Date(date);
      var nowDate = extractNowDate(nowOrOptions);
      var seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;
      var unit = typeof nowOrOptions === 'number' || nowOrOptions instanceof Date || (nowOrOptions == null ? void 0 : nowOrOptions.unit) === undefined ? resolveRelativeTimeUnit(seconds) : nowOrOptions.unit;
      var value = calculateRelativeTimeValue(seconds, unit);
      return new Intl.RelativeTimeFormat(locale, {
        numeric: 'auto'
      }).format(value, unit);
    } catch (error) {
      onError(new IntlError(exports.IntlErrorCode.FORMATTING_ERROR, error.message));
      return String(date);
    }
  }
  function list(value, formatOrOptions) {
    return getFormattedValue(value, formatOrOptions, formats == null ? void 0 : formats.list, function (options) {
      return new Intl.ListFormat(locale, options).format(value);
    });
  }
  return {
    dateTime: dateTime,
    number: number,
    relativeTime: relativeTime,
    list: list
  };
}

/** @deprecated Switch to `createFormatter` */
function createIntl() {
  var formatter = createFormatter.apply(void 0, arguments);
  return {
    formatDateTime: formatter.dateTime,
    formatNumber: formatter.number,
    formatRelativeTime: formatter.relativeTime
  };
}

var IntlContext = /*#__PURE__*/React.createContext(undefined);

function validateMessagesSegment(messages, invalidKeyLabels, parentPath) {
  Object.entries(messages).forEach(function (_ref) {
    var key = _ref[0],
      messageOrMessages = _ref[1];
    if (key.includes('.')) {
      var keyLabel = key;
      if (parentPath) keyLabel += " (at " + parentPath + ")";
      invalidKeyLabels.push(keyLabel);
    }
    if (messageOrMessages != null && typeof messageOrMessages === 'object') {
      validateMessagesSegment(messageOrMessages, invalidKeyLabels, [parentPath, key].filter(function (part) {
        return part != null;
      }).join('.'));
    }
  });
}
function validateMessages(messages, onError) {
  var invalidKeyLabels = [];
  validateMessagesSegment(messages, invalidKeyLabels);
  if (invalidKeyLabels.length > 0) {
    onError(new IntlError(exports.IntlErrorCode.INVALID_KEY, "Namespace keys can not contain the character \".\" as this is used to express nesting. Please remove it or replace it with another character.\n\nInvalid " + (invalidKeyLabels.length === 1 ? 'key' : 'keys') + ": " + invalidKeyLabels.join(', ') + "\n\nIf you're migrating from a flat structure, you can convert your messages as follows:\n\nimport {set} from \"lodash\";\n\nconst input = {\n  \"one.one\": \"1.1\",\n  \"one.two\": \"1.2\",\n  \"two.one.one\": \"2.1.1\"\n};\n\nconst output = Object.entries(input).reduce(\n  (acc, [key, value]) => set(acc, key, value),\n  {}\n);\n\n// Output:\n//\n// {\n//   \"one\": {\n//     \"one\": \"1.1\",\n//     \"two\": \"1.2\"\n//   },\n//   \"two\": {\n//     \"one\": {\n//       \"one\": \"2.1.1\"\n//     }\n//   }\n// }\n" ));
  }
}

var _excluded$1 = ["getMessageFallback", "messages", "onError"];
/**
 * Enhances the incoming props with defaults.
 */
function getInitializedConfig(_ref) {
  var getMessageFallback = _ref.getMessageFallback,
    messages = _ref.messages,
    onError = _ref.onError,
    rest = _objectWithoutPropertiesLoose(_ref, _excluded$1);
  var finalOnError = onError || defaultOnError;
  var finalGetMessageFallback = getMessageFallback || defaultGetMessageFallback;
  {
    if (messages) {
      validateMessages(messages, finalOnError);
    }
  }
  return _extends({}, rest, {
    messages: messages,
    onError: finalOnError,
    getMessageFallback: finalGetMessageFallback
  });
}

var _excluded = ["children"];
function IntlProvider(_ref) {
  var children = _ref.children,
    props = _objectWithoutPropertiesLoose(_ref, _excluded);
  var _useState = React.useState(function () {
      return new Map();
    }),
    messageFormatCache = _useState[0];
  return React__default["default"].createElement(IntlContext.Provider, {
    value: _extends({}, getInitializedConfig(props), {
      messageFormatCache: messageFormatCache
    })
  }, children);
}

function useIntlContext() {
  var context = React.useContext(IntlContext);
  if (!context) {
    throw new Error('No intl context found. Have you configured the provider?' );
  }
  return context;
}

function useTranslationsImpl(allMessages, namespace, namespacePrefix) {
  var _useIntlContext = useIntlContext(),
    defaultTranslationValues = _useIntlContext.defaultTranslationValues,
    globalFormats = _useIntlContext.formats,
    getMessageFallback = _useIntlContext.getMessageFallback,
    locale = _useIntlContext.locale,
    messageFormatCache = _useIntlContext.messageFormatCache,
    onError = _useIntlContext.onError,
    timeZone = _useIntlContext.timeZone;
  // The `namespacePrefix` is part of the type system.
  // See the comment in the hook invocation.
  allMessages = allMessages[namespacePrefix];
  namespace = resolveNamespace(namespace, namespacePrefix);
  var messagesOrError = React.useMemo(function () {
    return getMessagesOrError({
      messages: allMessages,
      namespace: namespace,
      onError: onError
    });
  }, [allMessages, namespace, onError]);
  var translate = React.useMemo(function () {
    return createBaseTranslator({
      messageFormatCache: messageFormatCache,
      getMessageFallback: getMessageFallback,
      messagesOrError: messagesOrError,
      defaultTranslationValues: defaultTranslationValues,
      namespace: namespace,
      onError: onError,
      formats: globalFormats,
      locale: locale,
      timeZone: timeZone
    });
  }, [messageFormatCache, getMessageFallback, messagesOrError, defaultTranslationValues, namespace, onError, globalFormats, locale, timeZone]);
  return translate;
}

/**
 * Translates messages from the given namespace by using the ICU syntax.
 * See https://formatjs.io/docs/core-concepts/icu-syntax.
 *
 * If no namespace is provided, all available messages are returned.
 * The namespace can also indicate nesting by using a dot
 * (e.g. `namespace.Component`).
 */
function useTranslations(namespace) {
  var context = useIntlContext();
  var messages = context.messages;
  // We have to wrap the actual hook so the type inference for the optional
  // namespace works correctly. See https://stackoverflow.com/a/71529575/343045
  // The prefix ("!") is arbitrary.
  return useTranslationsImpl({
    '!': messages
  },
  // @ts-expect-error
  namespace ? "!." + namespace : '!', '!');
}

function useLocale() {
  return useIntlContext().locale;
}

function getNow() {
  return new Date();
}
/**
 * Reading the current date via `new Date()` in components should be avoided, as
 * it causes components to be impure and can lead to flaky tests. Instead, this
 * hook can be used.
 *
 * By default, it returns the time when the component mounts. If `updateInterval`
 * is specified, the value will be updated based on the interval.
 *
 * You can however also return a static value from this hook, if you
 * configure the `now` parameter on the context provider. Note however,
 * that if `updateInterval` is configured in this case, the component
 * will initialize with the global value, but will afterwards update
 * continuously based on the interval.
 *
 * For unit tests, this can be mocked to a constant value. For end-to-end
 * testing, an environment parameter can be passed to the `now` parameter
 * of the provider to mock this to a static value.
 */
function useNow(options) {
  var updateInterval = options == null ? void 0 : options.updateInterval;
  var _useIntlContext = useIntlContext(),
    globalNow = _useIntlContext.now;
  var _useState = React.useState(globalNow || getNow()),
    now = _useState[0],
    setNow = _useState[1];
  React.useEffect(function () {
    if (!updateInterval) return;
    var intervalId = setInterval(function () {
      setNow(getNow());
    }, updateInterval);
    return function () {
      clearInterval(intervalId);
    };
  }, [globalNow, updateInterval]);
  return now;
}

function useTimeZone() {
  return useIntlContext().timeZone;
}

function useMessages() {
  return useIntlContext().messages;
}

function useFormatter() {
  var _useIntlContext = useIntlContext(),
    formats = _useIntlContext.formats,
    locale = _useIntlContext.locale,
    globalNow = _useIntlContext.now,
    onError = _useIntlContext.onError,
    timeZone = _useIntlContext.timeZone;
  return React.useMemo(function () {
    return createFormatter({
      formats: formats,
      locale: locale,
      now: globalNow,
      onError: onError,
      timeZone: timeZone
    });
  }, [formats, globalNow, locale, onError, timeZone]);
}

var hasWarned = false;
/** @deprecated Switch to `useFormatter` instead. */
function useIntl() {
  var _useIntlContext = useIntlContext(),
    formats = _useIntlContext.formats,
    locale = _useIntlContext.locale,
    globalNow = _useIntlContext.now,
    onError = _useIntlContext.onError,
    timeZone = _useIntlContext.timeZone;
  if (!hasWarned) {
    hasWarned = true;
    console.warn('`useIntl()` is deprecated and will be removed in the next major version. Please switch to `useFormatter()`.');
  }
  return React.useMemo(function () {
    return createIntl({
      formats: formats,
      locale: locale,
      now: globalNow,
      onError: onError,
      timeZone: timeZone
    });
  }, [formats, globalNow, locale, onError, timeZone]);
}

exports.IntlError = IntlError;
exports.IntlProvider = IntlProvider;
exports.createFormatter = createFormatter;
exports.createIntl = createIntl;
exports.createTranslator = createTranslator;
exports.useFormatter = useFormatter;
exports.useIntl = useIntl;
exports.useLocale = useLocale;
exports.useMessages = useMessages;
exports.useNow = useNow;
exports.useTimeZone = useTimeZone;
exports.useTranslations = useTranslations;
//# sourceMappingURL=use-intl.cjs.development.js.map
