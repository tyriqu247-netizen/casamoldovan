import { extends as _extends } from '../_virtual/use-intl.esm.js';
import IntlError, { IntlErrorCode } from './use-intl.esm.js';
import { defaultOnError } from './use-intl.esm6.js';

var SECOND = 1;
var MINUTE = SECOND * 60;
var HOUR = MINUTE * 60;
var DAY = HOUR * 24;
var WEEK = DAY * 7;
var MONTH = DAY * (365 / 12); // Approximation
var QUARTER = MONTH * 3;
var YEAR = DAY * 365;
var UNIT_SECONDS = {
  second: SECOND,
  seconds: SECOND,
  minute: MINUTE,
  minutes: MINUTE,
  hour: HOUR,
  hours: HOUR,
  day: DAY,
  days: DAY,
  week: WEEK,
  weeks: WEEK,
  month: MONTH,
  months: MONTH,
  quarter: QUARTER,
  quarters: QUARTER,
  year: YEAR,
  years: YEAR
};
function resolveRelativeTimeUnit(seconds) {
  var absValue = Math.abs(seconds);
  if (absValue < MINUTE) {
    return 'second';
  } else if (absValue < HOUR) {
    return 'minute';
  } else if (absValue < DAY) {
    return 'hour';
  } else if (absValue < WEEK) {
    return 'day';
  } else if (absValue < MONTH) {
    return 'week';
  } else if (absValue < YEAR) {
    return 'month';
  }
  return 'year';
}
function calculateRelativeTimeValue(seconds, unit) {
  // We have to round the resulting values, as `Intl.RelativeTimeFormat`
  // will include fractions like '2.1 hours ago'.
  return Math.round(seconds / UNIT_SECONDS[unit]);
}
function createFormatter(_ref) {
  var formats = _ref.formats,
    locale = _ref.locale,
    globalNow = _ref.now,
    _ref$onError = _ref.onError,
    onError = _ref$onError === void 0 ? defaultOnError : _ref$onError,
    globalTimeZone = _ref.timeZone;
  function resolveFormatOrOptions(typeFormats, formatOrOptions) {
    var options;
    if (typeof formatOrOptions === 'string') {
      var formatName = formatOrOptions;
      options = typeFormats == null ? void 0 : typeFormats[formatName];
      if (!options) {
        var error = new IntlError(IntlErrorCode.MISSING_FORMAT, process.env.NODE_ENV !== 'production' ? "Format `" + formatName + "` is not available. You can configure it on the provider or provide custom options." : undefined);
        onError(error);
        throw error;
      }
    } else {
      options = formatOrOptions;
    }
    return options;
  }
  function getFormattedValue(value, formatOrOptions, typeFormats, formatter) {
    var options;
    try {
      options = resolveFormatOrOptions(typeFormats, formatOrOptions);
    } catch (error) {
      return String(value);
    }
    try {
      return formatter(options);
    } catch (error) {
      onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));
      return String(value);
    }
  }
  function dateTime( /** If a number is supplied, this is interpreted as a UTC timestamp. */
  value,
  /** If a time zone is supplied, the `value` is converted to that time zone.
   * Otherwise the user time zone will be used. */
  formatOrOptions) {
    return getFormattedValue(value, formatOrOptions, formats == null ? void 0 : formats.dateTime, function (options) {
      var _options;
      if (!((_options = options) != null && _options.timeZone)) {
        if (globalTimeZone) {
          options = _extends({}, options, {
            timeZone: globalTimeZone
          });
        } else {
          onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, process.env.NODE_ENV !== 'production' ? "The `timeZone` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl-docs.vercel.app/docs/configuration#time-zone" : undefined));
        }
      }
      return new Intl.DateTimeFormat(locale, options).format(value);
    });
  }
  function number(value, formatOrOptions) {
    return getFormattedValue(value, formatOrOptions, formats == null ? void 0 : formats.number, function (options) {
      return new Intl.NumberFormat(locale, options).format(value);
    });
  }
  function getGlobalNow() {
    if (globalNow) {
      return globalNow;
    } else {
      onError(new IntlError(IntlErrorCode.ENVIRONMENT_FALLBACK, process.env.NODE_ENV !== 'production' ? "The `now` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl-docs.vercel.app/docs/configuration#now" : undefined));
      return new Date();
    }
  }
  function extractNowDate(nowOrOptions) {
    if (nowOrOptions instanceof Date || typeof nowOrOptions === 'number') {
      return new Date(nowOrOptions);
    }
    if ((nowOrOptions == null ? void 0 : nowOrOptions.now) !== undefined) {
      return new Date(nowOrOptions.now);
    }
    return getGlobalNow();
  }
  function relativeTime( /** The date time that needs to be formatted. */
  date, /** The reference point in time to which `date` will be formatted in relation to.  */
  nowOrOptions) {
    try {
      var dateDate = new Date(date);
      var nowDate = extractNowDate(nowOrOptions);
      var seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;
      var unit = typeof nowOrOptions === 'number' || nowOrOptions instanceof Date || (nowOrOptions == null ? void 0 : nowOrOptions.unit) === undefined ? resolveRelativeTimeUnit(seconds) : nowOrOptions.unit;
      var value = calculateRelativeTimeValue(seconds, unit);
      return new Intl.RelativeTimeFormat(locale, {
        numeric: 'auto'
      }).format(value, unit);
    } catch (error) {
      onError(new IntlError(IntlErrorCode.FORMATTING_ERROR, error.message));
      return String(date);
    }
  }
  function list(value, formatOrOptions) {
    return getFormattedValue(value, formatOrOptions, formats == null ? void 0 : formats.list, function (options) {
      return new Intl.ListFormat(locale, options).format(value);
    });
  }
  return {
    dateTime: dateTime,
    number: number,
    relativeTime: relativeTime,
    list: list
  };
}

export { createFormatter as default };
//# sourceMappingURL=use-intl.esm3.js.map
