import { extends as _extends } from '../_virtual/use-intl.esm.js';
import IntlMessageFormat from 'intl-messageformat';
import { isValidElement, cloneElement } from 'react';
import IntlError, { IntlErrorCode } from './use-intl.esm.js';
import convertFormatsToIntlMessageFormat from './use-intl.esm10.js';
import { defaultOnError, defaultGetMessageFallback } from './use-intl.esm6.js';

function resolvePath(messages, key, namespace) {
  if (!messages) {
    throw new Error(process.env.NODE_ENV !== 'production' ? "No messages available at `" + namespace + "`." : undefined);
  }
  var message = messages;
  key.split('.').forEach(function (part) {
    var next = message[part];
    if (part == null || next == null) {
      throw new Error(process.env.NODE_ENV !== 'production' ? "Could not resolve `" + key + "` in " + (namespace ? "`" + namespace + "`" : 'messages') + "." : undefined);
    }
    message = next;
  });
  return message;
}
function prepareTranslationValues(values) {
  if (Object.keys(values).length === 0) return undefined;
  // Workaround for https://github.com/formatjs/formatjs/issues/1467
  var transformedValues = {};
  Object.keys(values).forEach(function (key) {
    var index = 0;
    var value = values[key];
    var transformed;
    if (typeof value === 'function') {
      transformed = function transformed(chunks) {
        var result = value(chunks);
        return isValidElement(result) ? cloneElement(result, {
          key: key + index++
        }) : result;
      };
    } else {
      transformed = value;
    }
    transformedValues[key] = transformed;
  });
  return transformedValues;
}
function getMessagesOrError(_ref) {
  var messages = _ref.messages,
    namespace = _ref.namespace,
    _ref$onError = _ref.onError,
    onError = _ref$onError === void 0 ? defaultOnError : _ref$onError;
  try {
    if (!messages) {
      throw new Error(process.env.NODE_ENV !== 'production' ? "No messages were configured on the provider." : undefined);
    }
    var retrievedMessages = namespace ? resolvePath(messages, namespace) : messages;
    if (!retrievedMessages) {
      throw new Error(process.env.NODE_ENV !== 'production' ? "No messages for namespace `" + namespace + "` found." : undefined);
    }
    return retrievedMessages;
  } catch (error) {
    var intlError = new IntlError(IntlErrorCode.MISSING_MESSAGE, error.message);
    onError(intlError);
    return intlError;
  }
}
function getPlainMessage(candidate, values) {
  if (values) return undefined;
  var unescapedMessage = candidate.replace(/'([{}])/gi, '$1');
  // Placeholders can be in the message if there are default values,
  // or if the user has forgotten to provide values. In the latter
  // case we need to compile the message to receive an error.
  var hasPlaceholders = /<|{/.test(unescapedMessage);
  if (!hasPlaceholders) {
    return unescapedMessage;
  }
  return undefined;
}
function createBaseTranslator(_ref2) {
  var defaultTranslationValues = _ref2.defaultTranslationValues,
    globalFormats = _ref2.formats,
    _ref2$getMessageFallb = _ref2.getMessageFallback,
    getMessageFallback = _ref2$getMessageFallb === void 0 ? defaultGetMessageFallback : _ref2$getMessageFallb,
    locale = _ref2.locale,
    messageFormatCache = _ref2.messageFormatCache,
    messagesOrError = _ref2.messagesOrError,
    namespace = _ref2.namespace,
    onError = _ref2.onError,
    timeZone = _ref2.timeZone;
  function getFallbackFromErrorAndNotify(key, code, message) {
    var error = new IntlError(code, message);
    onError(error);
    return getMessageFallback({
      error: error,
      key: key,
      namespace: namespace
    });
  }
  function translateBaseFn( /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */
  key, /** Key value pairs for values to interpolate into the message. */
  values, /** Provide custom formats for numbers, dates and times. */
  formats) {
    if (messagesOrError instanceof IntlError) {
      // We have already warned about this during render
      return getMessageFallback({
        error: messagesOrError,
        key: key,
        namespace: namespace
      });
    }
    var messages = messagesOrError;
    var message;
    try {
      message = resolvePath(messages, key, namespace);
    } catch (error) {
      return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message);
    }
    function joinPath(parts) {
      return parts.filter(function (part) {
        return part != null;
      }).join('.');
    }
    var cacheKey = joinPath([locale, namespace, key, String(message)]);
    var messageFormat;
    if (messageFormatCache != null && messageFormatCache.has(cacheKey)) {
      messageFormat = messageFormatCache.get(cacheKey);
    } else {
      if (typeof message === 'object') {
        var code, errorMessage;
        if (Array.isArray(message)) {
          code = IntlErrorCode.INVALID_MESSAGE;
          if (process.env.NODE_ENV !== 'production') {
            errorMessage = "Message at `" + joinPath([namespace, key]) + "` resolved to an array, but only strings are supported. See https://next-intl-docs.vercel.app/docs/usage/messages#arrays-of-messages";
          }
        } else {
          code = IntlErrorCode.INSUFFICIENT_PATH;
          if (process.env.NODE_ENV !== 'production') {
            errorMessage = "Message at `" + joinPath([namespace, key]) + "` resolved to an object, but only strings are supported. Use a `.` to retrieve nested messages. See https://next-intl-docs.vercel.app/docs/usage/messages#structuring-messages";
          }
        }
        return getFallbackFromErrorAndNotify(key, code, errorMessage);
      }
      // Hot path that avoids creating an `IntlMessageFormat` instance
      var plainMessage = getPlainMessage(message, values);
      if (plainMessage) return plainMessage;
      try {
        messageFormat = new IntlMessageFormat(message, locale, convertFormatsToIntlMessageFormat(_extends({}, globalFormats, formats), timeZone));
      } catch (error) {
        return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, error.message);
      }
      messageFormatCache == null || messageFormatCache.set(cacheKey, messageFormat);
    }
    try {
      var formattedMessage = messageFormat.format(
      // @ts-ignore `intl-messageformat` expects a different format
      // for rich text elements since a recent minor update. This
      // needs to be evaluated in detail, possibly also in regards
      // to be able to format to parts.
      prepareTranslationValues(_extends({}, defaultTranslationValues, values)));
      if (formattedMessage == null) {
        throw new Error(process.env.NODE_ENV !== 'production' ? "Unable to format `" + key + "` in " + (namespace ? "namespace `" + namespace + "`" : 'messages') : undefined);
      }
      // Limit the function signature to return strings or React elements
      return isValidElement(formattedMessage) ||
      // Arrays of React elements
      Array.isArray(formattedMessage) || typeof formattedMessage === 'string' ? formattedMessage : String(formattedMessage);
    } catch (error) {
      return getFallbackFromErrorAndNotify(key, IntlErrorCode.FORMATTING_ERROR, error.message);
    }
  }
  function translateFn( /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */
  key, /** Key value pairs for values to interpolate into the message. */
  values, /** Provide custom formats for numbers, dates and times. */
  formats) {
    var result = translateBaseFn(key, values, formats);
    if (typeof result !== 'string') {
      return getFallbackFromErrorAndNotify(key, IntlErrorCode.INVALID_MESSAGE, process.env.NODE_ENV !== 'production' ? "The message `" + key + "` in " + (namespace ? "namespace `" + namespace + "`" : 'messages') + " didn't resolve to a string. If you want to format rich text, use `t.rich` instead." : undefined);
    }
    return result;
  }
  translateFn.rich = translateBaseFn;
  translateFn.raw = function ( /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */
  key) {
    if (messagesOrError instanceof IntlError) {
      // We have already warned about this during render
      return getMessageFallback({
        error: messagesOrError,
        key: key,
        namespace: namespace
      });
    }
    var messages = messagesOrError;
    try {
      return resolvePath(messages, key, namespace);
    } catch (error) {
      return getFallbackFromErrorAndNotify(key, IntlErrorCode.MISSING_MESSAGE, error.message);
    }
  };
  return translateFn;
}

export { createBaseTranslator as default, getMessagesOrError };
//# sourceMappingURL=use-intl.esm7.js.map
