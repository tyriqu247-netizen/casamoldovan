import IntlError, { IntlErrorCode } from './IntlError';
import createBaseTranslator, { getMessagesOrError } from './createBaseTranslator';
import resolveNamespace from './resolveNamespace';
export default function createTranslatorImpl({ getMessageFallback, messages, namespace, onError, ...rest }, namespacePrefix) {
    // The `namespacePrefix` is part of the type system.
    // See the comment in the function invocation.
    messages = messages[namespacePrefix];
    namespace = resolveNamespace(namespace, namespacePrefix);
    const translator = createBaseTranslator({
        ...rest,
        onError,
        getMessageFallback,
        messagesOrError: getMessagesOrError({
            messages,
            namespace,
            onError
        })
    });
    const originalRich = translator.rich;
    function base(...args) {
        return translator(...args);
    }
    // Augment `t.rich` to return plain strings
    base.rich = (key, 
    /** Key value pairs for values to interpolate into the message. */
    values, formats) => {
        // `chunks` is returned as a string when no React element
        // is used, therefore it's safe to cast this type.
        const result = originalRich(key, values, formats);
        // When only string chunks are provided to the parser, only strings should be returned here.
        if (typeof result !== 'string') {
            const error = new IntlError(IntlErrorCode.FORMATTING_ERROR, process.env.NODE_ENV !== 'production'
                ? "`createTranslator` only accepts functions for rich text formatting that receive and return strings.\n\nE.g. t.rich('rich', {b: (chunks) => `<b>${chunks}</b>`})"
                : undefined);
            onError(error);
            return getMessageFallback({ error, key, namespace });
        }
        return result;
    };
    base.raw = translator.raw;
    return base;
}
//# sourceMappingURL=createTranslatorImpl.js.map