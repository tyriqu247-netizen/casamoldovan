{"version":3,"file":"use-intl.cjs.production.min.js","sources":["../src/core/IntlError.tsx","../src/core/convertFormatsToIntlMessageFormat.tsx","../src/core/defaults.tsx","../src/core/createBaseTranslator.tsx","../src/core/resolveNamespace.tsx","../src/core/createFormatter.tsx","../src/core/createIntl.tsx","../src/react/IntlContext.tsx","../src/react/getInitializedConfig.tsx","../src/react/useIntlContext.tsx","../src/react/useNow.tsx","../src/react/useIntl.tsx","../src/react/IntlProvider.tsx","../src/core/createTranslator.tsx","../src/core/createTranslatorImpl.tsx","../src/react/useFormatter.tsx","../src/react/useLocale.tsx","../src/react/useMessages.tsx","../src/react/useTimeZone.tsx","../src/react/useTranslations.tsx","../src/react/useTranslationsImpl.tsx"],"sourcesContent":["export enum IntlErrorCode {\n  MISSING_MESSAGE = 'MISSING_MESSAGE',\n  MISSING_FORMAT = 'MISSING_FORMAT',\n  ENVIRONMENT_FALLBACK = 'ENVIRONMENT_FALLBACK',\n  INSUFFICIENT_PATH = 'INSUFFICIENT_PATH',\n  INVALID_MESSAGE = 'INVALID_MESSAGE',\n  INVALID_KEY = 'INVALID_KEY',\n  FORMATTING_ERROR = 'FORMATTING_ERROR'\n}\n\nexport default class IntlError extends Error {\n  public readonly code: IntlErrorCode;\n  public readonly originalMessage: string | undefined;\n\n  constructor(code: IntlErrorCode, originalMessage?: string) {\n    let message: string = code;\n    if (originalMessage) {\n      message += ': ' + originalMessage;\n    }\n    super(message);\n\n    this.code = code;\n    if (originalMessage) {\n      this.originalMessage = originalMessage;\n    }\n  }\n}\n","// eslint-disable-next-line import/no-named-as-default -- False positive\nimport IntlMessageFormat, {Formats as IntlFormats} from 'intl-messageformat';\nimport DateTimeFormatOptions from './DateTimeFormatOptions';\nimport Formats from './Formats';\nimport TimeZone from './TimeZone';\n\nfunction setTimeZoneInFormats(\n  formats: Record<string, DateTimeFormatOptions> | undefined,\n  timeZone: TimeZone\n) {\n  if (!formats) return formats;\n\n  // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n  // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n  return Object.keys(formats).reduce(\n    (acc: Record<string, DateTimeFormatOptions>, key) => {\n      acc[key] = {\n        timeZone,\n        ...formats[key]\n      };\n      return acc;\n    },\n    {}\n  );\n}\n\n/**\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\n * include both a time and a date in a value, therefore the separation doesn't\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\n * to convert the format before `intl-messageformat` can be used.\n */\nexport default function convertFormatsToIntlMessageFormat(\n  formats: Partial<Formats>,\n  timeZone?: TimeZone\n): Partial<IntlFormats> {\n  const formatsWithTimeZone = timeZone\n    ? {...formats, dateTime: setTimeZoneInFormats(formats.dateTime, timeZone)}\n    : formats;\n\n  const mfDateDefaults = IntlMessageFormat.formats.date as Formats['dateTime'];\n  const defaultDateFormats = timeZone\n    ? setTimeZoneInFormats(mfDateDefaults, timeZone)\n    : mfDateDefaults;\n\n  const mfTimeDefaults = IntlMessageFormat.formats.time as Formats['dateTime'];\n  const defaultTimeFormats = timeZone\n    ? setTimeZoneInFormats(mfTimeDefaults, timeZone)\n    : mfTimeDefaults;\n\n  return {\n    ...formatsWithTimeZone,\n    date: {\n      ...defaultDateFormats,\n      ...formatsWithTimeZone?.dateTime\n    },\n    time: {\n      ...defaultTimeFormats,\n      ...formatsWithTimeZone?.dateTime\n    }\n  };\n}\n","import IntlError from './IntlError';\n\n/**\n * Contains defaults that are used for all entry points into the core.\n * See also `InitializedIntlConfiguration`.\n */\n\nexport function defaultGetMessageFallback(props: {\n  error: IntlError;\n  key: string;\n  namespace?: string;\n}) {\n  return [props.namespace, props.key].filter((part) => part != null).join('.');\n}\n\nexport function defaultOnError(error: IntlError) {\n  console.error(error);\n}\n","// eslint-disable-next-line import/no-named-as-default -- False positive\nimport IntlMessageFormat from 'intl-messageformat';\nimport {\n  cloneElement,\n  isValidElement,\n  ReactElement,\n  ReactNode,\n  ReactNodeArray\n} from 'react';\nimport AbstractIntlMessages from './AbstractIntlMessages';\nimport Formats from './Formats';\nimport {InitializedIntlConfig} from './IntlConfig';\nimport IntlError, {IntlErrorCode} from './IntlError';\nimport MessageFormatCache from './MessageFormatCache';\nimport TranslationValues, {RichTranslationValues} from './TranslationValues';\nimport convertFormatsToIntlMessageFormat from './convertFormatsToIntlMessageFormat';\nimport {defaultGetMessageFallback, defaultOnError} from './defaults';\nimport MessageKeys from './utils/MessageKeys';\nimport NestedKeyOf from './utils/NestedKeyOf';\nimport NestedValueOf from './utils/NestedValueOf';\n\nfunction resolvePath(\n  messages: AbstractIntlMessages | undefined,\n  key: string,\n  namespace?: string\n) {\n  if (!messages) {\n    throw new Error(\n      process.env.NODE_ENV !== 'production'\n        ? `No messages available at \\`${namespace}\\`.`\n        : undefined\n    );\n  }\n\n  let message = messages;\n\n  key.split('.').forEach((part) => {\n    const next = (message as any)[part];\n\n    if (part == null || next == null) {\n      throw new Error(\n        process.env.NODE_ENV !== 'production'\n          ? `Could not resolve \\`${key}\\` in ${\n              namespace ? `\\`${namespace}\\`` : 'messages'\n            }.`\n          : undefined\n      );\n    }\n\n    message = next;\n  });\n\n  return message;\n}\n\nfunction prepareTranslationValues(values: RichTranslationValues) {\n  if (Object.keys(values).length === 0) return undefined;\n\n  // Workaround for https://github.com/formatjs/formatjs/issues/1467\n  const transformedValues: RichTranslationValues = {};\n  Object.keys(values).forEach((key) => {\n    let index = 0;\n    const value = values[key];\n\n    let transformed;\n    if (typeof value === 'function') {\n      transformed = (chunks: ReactNode) => {\n        const result = value(chunks);\n\n        return isValidElement(result)\n          ? cloneElement(result, {key: key + index++})\n          : result;\n      };\n    } else {\n      transformed = value;\n    }\n\n    transformedValues[key] = transformed;\n  });\n\n  return transformedValues;\n}\n\nexport function getMessagesOrError<Messages extends AbstractIntlMessages>({\n  messages,\n  namespace,\n  onError = defaultOnError\n}: {\n  messages: Messages;\n  namespace?: string;\n  onError?(error: IntlError): void;\n}) {\n  try {\n    if (!messages) {\n      throw new Error(\n        process.env.NODE_ENV !== 'production'\n          ? `No messages were configured on the provider.`\n          : undefined\n      );\n    }\n\n    const retrievedMessages = namespace\n      ? resolvePath(messages, namespace)\n      : messages;\n\n    if (!retrievedMessages) {\n      throw new Error(\n        process.env.NODE_ENV !== 'production'\n          ? `No messages for namespace \\`${namespace}\\` found.`\n          : undefined\n      );\n    }\n\n    return retrievedMessages;\n  } catch (error) {\n    const intlError = new IntlError(\n      IntlErrorCode.MISSING_MESSAGE,\n      (error as Error).message\n    );\n    onError(intlError);\n    return intlError;\n  }\n}\n\nexport type CreateBaseTranslatorProps<Messages> = InitializedIntlConfig & {\n  messageFormatCache?: MessageFormatCache;\n  defaultTranslationValues?: RichTranslationValues;\n  namespace?: string;\n  messagesOrError: Messages | IntlError;\n};\n\nfunction getPlainMessage(candidate: string, values?: unknown) {\n  if (values) return undefined;\n\n  const unescapedMessage = candidate.replace(/'([{}])/gi, '$1');\n\n  // Placeholders can be in the message if there are default values,\n  // or if the user has forgotten to provide values. In the latter\n  // case we need to compile the message to receive an error.\n  const hasPlaceholders = /<|{/.test(unescapedMessage);\n\n  if (!hasPlaceholders) {\n    return unescapedMessage;\n  }\n\n  return undefined;\n}\n\nexport default function createBaseTranslator<\n  Messages extends AbstractIntlMessages,\n  NestedKey extends NestedKeyOf<Messages>\n>({\n  defaultTranslationValues,\n  formats: globalFormats,\n  getMessageFallback = defaultGetMessageFallback,\n  locale,\n  messageFormatCache,\n  messagesOrError,\n  namespace,\n  onError,\n  timeZone\n}: CreateBaseTranslatorProps<Messages>) {\n  function getFallbackFromErrorAndNotify(\n    key: string,\n    code: IntlErrorCode,\n    message?: string\n  ) {\n    const error = new IntlError(code, message);\n    onError(error);\n    return getMessageFallback({error, key, namespace});\n  }\n\n  function translateBaseFn(\n    /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n    key: string,\n    /** Key value pairs for values to interpolate into the message. */\n    values?: RichTranslationValues,\n    /** Provide custom formats for numbers, dates and times. */\n    formats?: Partial<Formats>\n  ): string | ReactElement | ReactNodeArray {\n    if (messagesOrError instanceof IntlError) {\n      // We have already warned about this during render\n      return getMessageFallback({\n        error: messagesOrError,\n        key,\n        namespace\n      });\n    }\n    const messages = messagesOrError;\n\n    let message;\n    try {\n      message = resolvePath(messages, key, namespace);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(\n        key,\n        IntlErrorCode.MISSING_MESSAGE,\n        (error as Error).message\n      );\n    }\n\n    function joinPath(parts: Array<string | undefined>) {\n      return parts.filter((part) => part != null).join('.');\n    }\n\n    const cacheKey = joinPath([locale, namespace, key, String(message)]);\n\n    let messageFormat: IntlMessageFormat;\n    if (messageFormatCache?.has(cacheKey)) {\n      messageFormat = messageFormatCache.get(cacheKey)!;\n    } else {\n      if (typeof message === 'object') {\n        let code, errorMessage;\n        if (Array.isArray(message)) {\n          code = IntlErrorCode.INVALID_MESSAGE;\n          if (process.env.NODE_ENV !== 'production') {\n            errorMessage = `Message at \\`${joinPath([\n              namespace,\n              key\n            ])}\\` resolved to an array, but only strings are supported. See https://next-intl-docs.vercel.app/docs/usage/messages#arrays-of-messages`;\n          }\n        } else {\n          code = IntlErrorCode.INSUFFICIENT_PATH;\n          if (process.env.NODE_ENV !== 'production') {\n            errorMessage = `Message at \\`${joinPath([\n              namespace,\n              key\n            ])}\\` resolved to an object, but only strings are supported. Use a \\`.\\` to retrieve nested messages. See https://next-intl-docs.vercel.app/docs/usage/messages#structuring-messages`;\n          }\n        }\n\n        return getFallbackFromErrorAndNotify(key, code, errorMessage);\n      }\n\n      // Hot path that avoids creating an `IntlMessageFormat` instance\n      const plainMessage = getPlainMessage(message as string, values);\n      if (plainMessage) return plainMessage;\n\n      try {\n        messageFormat = new IntlMessageFormat(\n          message,\n          locale,\n          convertFormatsToIntlMessageFormat(\n            {...globalFormats, ...formats},\n            timeZone\n          )\n        );\n      } catch (error) {\n        return getFallbackFromErrorAndNotify(\n          key,\n          IntlErrorCode.INVALID_MESSAGE,\n          (error as Error).message\n        );\n      }\n\n      messageFormatCache?.set(cacheKey, messageFormat);\n    }\n\n    try {\n      const formattedMessage = messageFormat.format(\n        // @ts-ignore `intl-messageformat` expects a different format\n        // for rich text elements since a recent minor update. This\n        // needs to be evaluated in detail, possibly also in regards\n        // to be able to format to parts.\n        prepareTranslationValues({...defaultTranslationValues, ...values})\n      );\n\n      if (formattedMessage == null) {\n        throw new Error(\n          process.env.NODE_ENV !== 'production'\n            ? `Unable to format \\`${key}\\` in ${\n                namespace ? `namespace \\`${namespace}\\`` : 'messages'\n              }`\n            : undefined\n        );\n      }\n\n      // Limit the function signature to return strings or React elements\n      return isValidElement(formattedMessage) ||\n        // Arrays of React elements\n        Array.isArray(formattedMessage) ||\n        typeof formattedMessage === 'string'\n        ? formattedMessage\n        : String(formattedMessage);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(\n        key,\n        IntlErrorCode.FORMATTING_ERROR,\n        (error as Error).message\n      );\n    }\n  }\n\n  function translateFn<\n    TargetKey extends MessageKeys<\n      NestedValueOf<Messages, NestedKey>,\n      NestedKeyOf<NestedValueOf<Messages, NestedKey>>\n    >\n  >(\n    /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n    key: TargetKey,\n    /** Key value pairs for values to interpolate into the message. */\n    values?: TranslationValues,\n    /** Provide custom formats for numbers, dates and times. */\n    formats?: Partial<Formats>\n  ): string {\n    const result = translateBaseFn(key, values, formats);\n\n    if (typeof result !== 'string') {\n      return getFallbackFromErrorAndNotify(\n        key,\n        IntlErrorCode.INVALID_MESSAGE,\n        process.env.NODE_ENV !== 'production'\n          ? `The message \\`${key}\\` in ${\n              namespace ? `namespace \\`${namespace}\\`` : 'messages'\n            } didn't resolve to a string. If you want to format rich text, use \\`t.rich\\` instead.`\n          : undefined\n      );\n    }\n\n    return result;\n  }\n\n  translateFn.rich = translateBaseFn;\n\n  translateFn.raw = (\n    /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n    key: string\n  ): any => {\n    if (messagesOrError instanceof IntlError) {\n      // We have already warned about this during render\n      return getMessageFallback({\n        error: messagesOrError,\n        key,\n        namespace\n      });\n    }\n    const messages = messagesOrError;\n\n    try {\n      return resolvePath(messages, key, namespace);\n    } catch (error) {\n      return getFallbackFromErrorAndNotify(\n        key,\n        IntlErrorCode.MISSING_MESSAGE,\n        (error as Error).message\n      );\n    }\n  };\n\n  return translateFn;\n}\n","/**\n * For the strictly typed messages to work we have to wrap the namespace into\n * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045\n */\nexport default function resolveNamespace(\n  namespace: string,\n  namespacePrefix: string\n) {\n  return namespace === namespacePrefix\n    ? undefined\n    : namespace.slice((namespacePrefix + '.').length);\n}\n","import DateTimeFormatOptions from './DateTimeFormatOptions';\nimport Formats from './Formats';\nimport IntlError, {IntlErrorCode} from './IntlError';\nimport NumberFormatOptions from './NumberFormatOptions';\nimport RelativeTimeFormatOptions from './RelativeTimeFormatOptions';\nimport TimeZone from './TimeZone';\nimport {defaultOnError} from './defaults';\n\nconst SECOND = 1;\nconst MINUTE = SECOND * 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst QUARTER = MONTH * 3;\nconst YEAR = DAY * 365;\n\nconst UNIT_SECONDS: Record<Intl.RelativeTimeFormatUnit, number> = {\n  second: SECOND,\n  seconds: SECOND,\n  minute: MINUTE,\n  minutes: MINUTE,\n  hour: HOUR,\n  hours: HOUR,\n  day: DAY,\n  days: DAY,\n  week: WEEK,\n  weeks: WEEK,\n  month: MONTH,\n  months: MONTH,\n  quarter: QUARTER,\n  quarters: QUARTER,\n  year: YEAR,\n  years: YEAR\n} as const;\n\nfunction resolveRelativeTimeUnit(seconds: number) {\n  const absValue = Math.abs(seconds);\n\n  if (absValue < MINUTE) {\n    return 'second';\n  } else if (absValue < HOUR) {\n    return 'minute';\n  } else if (absValue < DAY) {\n    return 'hour';\n  } else if (absValue < WEEK) {\n    return 'day';\n  } else if (absValue < MONTH) {\n    return 'week';\n  } else if (absValue < YEAR) {\n    return 'month';\n  }\n  return 'year';\n}\n\nfunction calculateRelativeTimeValue(\n  seconds: number,\n  unit: Intl.RelativeTimeFormatUnit\n) {\n  // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n  // will include fractions like '2.1 hours ago'.\n  return Math.round(seconds / UNIT_SECONDS[unit]);\n}\n\ntype Props = {\n  locale: string;\n  timeZone?: TimeZone;\n  onError?(error: IntlError): void;\n  formats?: Partial<Formats>;\n  now?: Date;\n};\n\nexport default function createFormatter({\n  formats,\n  locale,\n  now: globalNow,\n  onError = defaultOnError,\n  timeZone: globalTimeZone\n}: Props) {\n  function resolveFormatOrOptions<Options>(\n    typeFormats: Record<string, Options> | undefined,\n    formatOrOptions?: string | Options\n  ) {\n    let options;\n    if (typeof formatOrOptions === 'string') {\n      const formatName = formatOrOptions;\n      options = typeFormats?.[formatName];\n\n      if (!options) {\n        const error = new IntlError(\n          IntlErrorCode.MISSING_FORMAT,\n          process.env.NODE_ENV !== 'production'\n            ? `Format \\`${formatName}\\` is not available. You can configure it on the provider or provide custom options.`\n            : undefined\n        );\n        onError(error);\n        throw error;\n      }\n    } else {\n      options = formatOrOptions;\n    }\n\n    return options;\n  }\n\n  function getFormattedValue<Value, Options>(\n    value: Value,\n    formatOrOptions: string | Options | undefined,\n    typeFormats: Record<string, Options> | undefined,\n    formatter: (options?: Options) => string\n  ) {\n    let options;\n    try {\n      options = resolveFormatOrOptions(typeFormats, formatOrOptions);\n    } catch (error) {\n      return String(value);\n    }\n\n    try {\n      return formatter(options);\n    } catch (error) {\n      onError(\n        new IntlError(IntlErrorCode.FORMATTING_ERROR, (error as Error).message)\n      );\n      return String(value);\n    }\n  }\n\n  function dateTime(\n    /** If a number is supplied, this is interpreted as a UTC timestamp. */\n    value: Date | number,\n    /** If a time zone is supplied, the `value` is converted to that time zone.\n     * Otherwise the user time zone will be used. */\n    formatOrOptions?: string | DateTimeFormatOptions\n  ) {\n    return getFormattedValue(\n      value,\n      formatOrOptions,\n      formats?.dateTime,\n      (options) => {\n        if (!options?.timeZone) {\n          if (globalTimeZone) {\n            options = {...options, timeZone: globalTimeZone};\n          } else {\n            onError(\n              new IntlError(\n                IntlErrorCode.ENVIRONMENT_FALLBACK,\n                process.env.NODE_ENV !== 'production'\n                  ? `The \\`timeZone\\` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl-docs.vercel.app/docs/configuration#time-zone`\n                  : undefined\n              )\n            );\n          }\n        }\n\n        return new Intl.DateTimeFormat(locale, options).format(value);\n      }\n    );\n  }\n\n  function number(\n    value: number | bigint,\n    formatOrOptions?: string | NumberFormatOptions\n  ) {\n    return getFormattedValue(\n      value,\n      formatOrOptions,\n      formats?.number,\n      (options) => new Intl.NumberFormat(locale, options).format(value)\n    );\n  }\n\n  function getGlobalNow() {\n    if (globalNow) {\n      return globalNow;\n    } else {\n      onError(\n        new IntlError(\n          IntlErrorCode.ENVIRONMENT_FALLBACK,\n          process.env.NODE_ENV !== 'production'\n            ? `The \\`now\\` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl-docs.vercel.app/docs/configuration#now`\n            : undefined\n        )\n      );\n      return new Date();\n    }\n  }\n\n  function extractNowDate(\n    nowOrOptions?: RelativeTimeFormatOptions['now'] | RelativeTimeFormatOptions\n  ) {\n    if (nowOrOptions instanceof Date || typeof nowOrOptions === 'number') {\n      return new Date(nowOrOptions);\n    }\n    if (nowOrOptions?.now !== undefined) {\n      return new Date(nowOrOptions.now);\n    }\n    return getGlobalNow();\n  }\n\n  function relativeTime(\n    /** The date time that needs to be formatted. */\n    date: number | Date,\n    /** The reference point in time to which `date` will be formatted in relation to.  */\n    nowOrOptions?: RelativeTimeFormatOptions['now'] | RelativeTimeFormatOptions\n  ) {\n    try {\n      const dateDate = new Date(date);\n      const nowDate = extractNowDate(nowOrOptions);\n      const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n\n      const unit =\n        typeof nowOrOptions === 'number' ||\n        nowOrOptions instanceof Date ||\n        nowOrOptions?.unit === undefined\n          ? resolveRelativeTimeUnit(seconds)\n          : nowOrOptions.unit;\n\n      const value = calculateRelativeTimeValue(seconds, unit);\n\n      return new Intl.RelativeTimeFormat(locale, {\n        numeric: 'auto'\n      }).format(value, unit);\n    } catch (error) {\n      onError(\n        new IntlError(IntlErrorCode.FORMATTING_ERROR, (error as Error).message)\n      );\n      return String(date);\n    }\n  }\n\n  function list(\n    value: Iterable<string>,\n    formatOrOptions?: string | Intl.ListFormatOptions\n  ) {\n    return getFormattedValue(value, formatOrOptions, formats?.list, (options) =>\n      new Intl.ListFormat(locale, options).format(value)\n    );\n  }\n\n  return {dateTime, number, relativeTime, list};\n}\n","import createFormatter from './createFormatter';\n\n/** @deprecated Switch to `createFormatter` */\nexport default function createIntl(\n  ...args: Parameters<typeof createFormatter>\n) {\n  const formatter = createFormatter(...args);\n  return {\n    formatDateTime: formatter.dateTime,\n    formatNumber: formatter.number,\n    formatRelativeTime: formatter.relativeTime\n  };\n}\n","import {createContext} from 'react';\nimport {InitializedIntlConfig} from '../core/IntlConfig';\nimport MessageFormatCache from '../core/MessageFormatCache';\n\nconst IntlContext = createContext<\n  | (InitializedIntlConfig & {\n      messageFormatCache?: MessageFormatCache;\n    })\n  | undefined\n>(undefined);\n\nexport default IntlContext;\n","import IntlConfig from '../core/IntlConfig';\nimport {defaultGetMessageFallback, defaultOnError} from '../core/defaults';\nimport validateMessages from '../core/validateMessages';\n\n/**\n * Enhances the incoming props with defaults.\n */\nexport default function getInitializedConfig<\n  // This is a generic to allow for stricter typing. E.g.\n  // the RSC integration always provides a `now` value.\n  Props extends Omit<IntlConfig, 'children'>\n>({getMessageFallback, messages, onError, ...rest}: Props) {\n  const finalOnError = onError || defaultOnError;\n  const finalGetMessageFallback =\n    getMessageFallback || defaultGetMessageFallback;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (messages) {\n      validateMessages(messages, finalOnError);\n    }\n  }\n\n  return {\n    ...rest,\n    messages,\n    onError: finalOnError,\n    getMessageFallback: finalGetMessageFallback\n  };\n}\n","import {useContext} from 'react';\nimport IntlContext from './IntlContext';\n\nexport default function useIntlContext() {\n  const context = useContext(IntlContext);\n\n  if (!context) {\n    throw new Error(\n      process.env.NODE_ENV !== 'production'\n        ? 'No intl context found. Have you configured the provider?'\n        : undefined\n    );\n  }\n\n  return context;\n}\n","import {useState, useEffect} from 'react';\nimport useIntlContext from './useIntlContext';\n\ntype Options = {\n  updateInterval?: number;\n};\n\nfunction getNow() {\n  return new Date();\n}\n\n/**\n * Reading the current date via `new Date()` in components should be avoided, as\n * it causes components to be impure and can lead to flaky tests. Instead, this\n * hook can be used.\n *\n * By default, it returns the time when the component mounts. If `updateInterval`\n * is specified, the value will be updated based on the interval.\n *\n * You can however also return a static value from this hook, if you\n * configure the `now` parameter on the context provider. Note however,\n * that if `updateInterval` is configured in this case, the component\n * will initialize with the global value, but will afterwards update\n * continuously based on the interval.\n *\n * For unit tests, this can be mocked to a constant value. For end-to-end\n * testing, an environment parameter can be passed to the `now` parameter\n * of the provider to mock this to a static value.\n */\nexport default function useNow(options?: Options) {\n  const updateInterval = options?.updateInterval;\n\n  const {now: globalNow} = useIntlContext();\n  const [now, setNow] = useState(globalNow || getNow());\n\n  useEffect(() => {\n    if (!updateInterval) return;\n\n    const intervalId = setInterval(() => {\n      setNow(getNow());\n    }, updateInterval);\n\n    return () => {\n      clearInterval(intervalId);\n    };\n  }, [globalNow, updateInterval]);\n\n  return now;\n}\n","import {useMemo} from 'react';\nimport createIntl from '../core/createIntl';\nimport useIntlContext from './useIntlContext';\n\nlet hasWarned = false;\n\n/** @deprecated Switch to `useFormatter` instead. */\nexport default function useIntl() {\n  const {formats, locale, now: globalNow, onError, timeZone} = useIntlContext();\n\n  if (!hasWarned) {\n    hasWarned = true;\n    console.warn(\n      '`useIntl()` is deprecated and will be removed in the next major version. Please switch to `useFormatter()`.'\n    );\n  }\n\n  return useMemo(\n    () =>\n      createIntl({\n        formats,\n        locale,\n        now: globalNow,\n        onError,\n        timeZone\n      }),\n    [formats, globalNow, locale, onError, timeZone]\n  );\n}\n","import React, {ReactNode, useState} from 'react';\nimport IntlConfig from '../core/IntlConfig';\nimport IntlContext from './IntlContext';\nimport getInitializedConfig from './getInitializedConfig';\n\ntype Props = IntlConfig & {\n  children: ReactNode;\n};\n\nexport default function IntlProvider({children, ...props}: Props) {\n  const [messageFormatCache] = useState(() => new Map());\n\n  return (\n    <IntlContext.Provider\n      value={{\n        ...getInitializedConfig(props),\n        messageFormatCache\n      }}\n    >\n      {children}\n    </IntlContext.Provider>\n  );\n}\n","import Formats from './Formats';\nimport IntlConfig from './IntlConfig';\nimport TranslationValues from './TranslationValues';\nimport createTranslatorImpl, {\n  CoreRichTranslationValues\n} from './createTranslatorImpl';\nimport {defaultGetMessageFallback, defaultOnError} from './defaults';\nimport MessageKeys from './utils/MessageKeys';\nimport NamespaceKeys from './utils/NamespaceKeys';\nimport NestedKeyOf from './utils/NestedKeyOf';\nimport NestedValueOf from './utils/NestedValueOf';\n\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */\nexport default function createTranslator<\n  NestedKey extends NamespaceKeys<\n    IntlMessages,\n    NestedKeyOf<IntlMessages>\n  > = never\n>({\n  getMessageFallback = defaultGetMessageFallback,\n  messages,\n  namespace,\n  onError = defaultOnError,\n  ...rest\n}: Omit<IntlConfig<IntlMessages>, 'defaultTranslationValues' | 'messages'> & {\n  messages: NonNullable<IntlConfig<IntlMessages>['messages']>;\n  namespace?: NestedKey;\n}): // Explicitly defining the return type is necessary as TypeScript would get it wrong\n{\n  // Default invocation\n  <\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey,\n    values?: TranslationValues,\n    formats?: Partial<Formats>\n  ): string;\n\n  // `rich`\n  rich<\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey,\n    values?: CoreRichTranslationValues,\n    formats?: Partial<Formats>\n  ): string;\n\n  // `raw`\n  raw<\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey\n  ): any;\n} {\n  // We have to wrap the actual function so the type inference for the optional\n  // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n  // The prefix (\"!\") is arbitrary.\n  return createTranslatorImpl<\n    {'!': IntlMessages},\n    [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n  >(\n    {\n      ...rest,\n      onError,\n      getMessageFallback,\n      messages: {'!': messages},\n      namespace: namespace ? `!.${namespace}` : '!'\n    },\n    '!'\n  );\n}\n","import AbstractIntlMessages from './AbstractIntlMessages';\nimport {InitializedIntlConfig} from './IntlConfig';\nimport IntlError, {IntlErrorCode} from './IntlError';\nimport {RichTranslationValues, TranslationValue} from './TranslationValues';\nimport createBaseTranslator, {getMessagesOrError} from './createBaseTranslator';\nimport resolveNamespace from './resolveNamespace';\nimport NestedKeyOf from './utils/NestedKeyOf';\n\nexport type CoreRichTranslationValues = Record<\n  string,\n  TranslationValue | ((chunks: string) => string)\n>;\n\nexport type CreateTranslatorImplProps<Messages> = Omit<\n  InitializedIntlConfig,\n  'messages'\n> & {\n  namespace: string;\n  messages: Messages;\n};\n\nexport default function createTranslatorImpl<\n  Messages extends AbstractIntlMessages,\n  NestedKey extends NestedKeyOf<Messages>\n>(\n  {\n    getMessageFallback,\n    messages,\n    namespace,\n    onError,\n    ...rest\n  }: CreateTranslatorImplProps<Messages>,\n  namespacePrefix: string\n) {\n  // The `namespacePrefix` is part of the type system.\n  // See the comment in the function invocation.\n  messages = messages[namespacePrefix] as Messages;\n  namespace = resolveNamespace(namespace, namespacePrefix) as NestedKey;\n\n  const translator = createBaseTranslator<Messages, NestedKey>({\n    ...rest,\n    onError,\n    getMessageFallback,\n    messagesOrError: getMessagesOrError({\n      messages,\n      namespace,\n      onError\n    }) as Messages | IntlError\n  });\n\n  const originalRich = translator.rich;\n\n  function base(...args: Parameters<typeof translator>) {\n    return translator(...args);\n  }\n\n  // Augment `t.rich` to return plain strings\n  base.rich = (\n    key: Parameters<typeof originalRich>[0],\n    /** Key value pairs for values to interpolate into the message. */\n    values: CoreRichTranslationValues,\n    formats?: Parameters<typeof originalRich>[2]\n  ): string => {\n    // `chunks` is returned as a string when no React element\n    // is used, therefore it's safe to cast this type.\n    const result = originalRich(key, values as RichTranslationValues, formats);\n\n    // When only string chunks are provided to the parser, only strings should be returned here.\n    if (typeof result !== 'string') {\n      const error = new IntlError(\n        IntlErrorCode.FORMATTING_ERROR,\n        process.env.NODE_ENV !== 'production'\n          ? \"`createTranslator` only accepts functions for rich text formatting that receive and return strings.\\n\\nE.g. t.rich('rich', {b: (chunks) => `<b>${chunks}</b>`})\"\n          : undefined\n      );\n\n      onError(error);\n      return getMessageFallback({error, key, namespace});\n    }\n\n    return result;\n  };\n\n  base.raw = translator.raw;\n\n  return base;\n}\n","import {useMemo} from 'react';\nimport createFormatter from '../core/createFormatter';\nimport useIntlContext from './useIntlContext';\n\nexport default function useFormatter() {\n  const {formats, locale, now: globalNow, onError, timeZone} = useIntlContext();\n\n  return useMemo(\n    () =>\n      createFormatter({\n        formats,\n        locale,\n        now: globalNow,\n        onError,\n        timeZone\n      }),\n    [formats, globalNow, locale, onError, timeZone]\n  );\n}\n","import useIntlContext from './useIntlContext';\n\nexport default function useLocale() {\n  return useIntlContext().locale;\n}\n","import useIntlContext from './useIntlContext';\n\nexport default function useMessages() {\n  return useIntlContext().messages;\n}\n","import useIntlContext from './useIntlContext';\n\nexport default function useTimeZone() {\n  return useIntlContext().timeZone;\n}\n","import {ReactElement, ReactNodeArray} from 'react';\nimport Formats from '../core/Formats';\nimport TranslationValues, {\n  RichTranslationValues\n} from '../core/TranslationValues';\nimport MessageKeys from '../core/utils/MessageKeys';\nimport NamespaceKeys from '../core/utils/NamespaceKeys';\nimport NestedKeyOf from '../core/utils/NestedKeyOf';\nimport NestedValueOf from '../core/utils/NestedValueOf';\nimport useIntlContext from './useIntlContext';\nimport useTranslationsImpl from './useTranslationsImpl';\n\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */\nexport default function useTranslations<\n  NestedKey extends NamespaceKeys<\n    IntlMessages,\n    NestedKeyOf<IntlMessages>\n  > = never\n>(\n  namespace?: NestedKey\n): // Explicitly defining the return type is necessary as TypeScript would get it wrong\n{\n  // Default invocation\n  <\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey,\n    values?: TranslationValues,\n    formats?: Partial<Formats>\n  ): string;\n\n  // `rich`\n  rich<\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey,\n    values?: RichTranslationValues,\n    formats?: Partial<Formats>\n  ): string | ReactElement | ReactNodeArray;\n\n  // `raw`\n  raw<\n    TargetKey extends MessageKeys<\n      NestedValueOf<\n        {'!': IntlMessages},\n        [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n      >,\n      NestedKeyOf<\n        NestedValueOf<\n          {'!': IntlMessages},\n          [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n        >\n      >\n    >\n  >(\n    key: TargetKey\n  ): any;\n} {\n  const context = useIntlContext();\n  const messages = context.messages as IntlMessages;\n\n  // We have to wrap the actual hook so the type inference for the optional\n  // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n  // The prefix (\"!\") is arbitrary.\n  return useTranslationsImpl<\n    {'!': IntlMessages},\n    [NestedKey] extends [never] ? '!' : `!.${NestedKey}`\n  >(\n    {'!': messages},\n    // @ts-expect-error\n    namespace ? `!.${namespace}` : '!',\n    '!'\n  );\n}\n","import {useMemo} from 'react';\nimport AbstractIntlMessages from '../core/AbstractIntlMessages';\nimport createBaseTranslator, {\n  getMessagesOrError\n} from '../core/createBaseTranslator';\nimport resolveNamespace from '../core/resolveNamespace';\nimport NestedKeyOf from '../core/utils/NestedKeyOf';\nimport useIntlContext from './useIntlContext';\n\nexport default function useTranslationsImpl<\n  Messages extends AbstractIntlMessages,\n  NestedKey extends NestedKeyOf<Messages>\n>(allMessages: Messages, namespace: NestedKey, namespacePrefix: string) {\n  const {\n    defaultTranslationValues,\n    formats: globalFormats,\n    getMessageFallback,\n    locale,\n    messageFormatCache,\n    onError,\n    timeZone\n  } = useIntlContext();\n\n  // The `namespacePrefix` is part of the type system.\n  // See the comment in the hook invocation.\n  allMessages = allMessages[namespacePrefix] as Messages;\n  namespace = resolveNamespace(namespace, namespacePrefix) as NestedKey;\n\n  const messagesOrError = useMemo(\n    () => getMessagesOrError({messages: allMessages, namespace, onError}),\n    [allMessages, namespace, onError]\n  );\n\n  const translate = useMemo(\n    () =>\n      createBaseTranslator({\n        messageFormatCache,\n        getMessageFallback,\n        messagesOrError,\n        defaultTranslationValues,\n        namespace,\n        onError,\n        formats: globalFormats,\n        locale,\n        timeZone\n      }),\n    [\n      messageFormatCache,\n      getMessageFallback,\n      messagesOrError,\n      defaultTranslationValues,\n      namespace,\n      onError,\n      globalFormats,\n      locale,\n      timeZone\n    ]\n  );\n\n  return translate;\n}\n"],"names":["IntlErrorCode","IntlError","_Error","code","originalMessage","_this","message","call","this","_wrapNativeSuper","Error","setTimeZoneInFormats","formats","timeZone","Object","keys","reduce","acc","key","_extends","defaultGetMessageFallback","props","namespace","filter","part","join","defaultOnError","error","console","resolvePath","messages","undefined","split","forEach","next","getMessagesOrError","_ref","_ref$onError","onError","retrievedMessages","intlError","MISSING_MESSAGE","createBaseTranslator","_ref2","defaultTranslationValues","globalFormats","_ref2$getMessageFallb","getMessageFallback","locale","messageFormatCache","messagesOrError","getFallbackFromErrorAndNotify","translateBaseFn","values","messageFormat","cacheKey","String","has","get","Array","isArray","INVALID_MESSAGE","INSUFFICIENT_PATH","errorMessage","plainMessage","candidate","unescapedMessage","replace","test","getPlainMessage","IntlMessageFormat","formatsWithTimeZone","dateTime","mfDateDefaults","date","defaultDateFormats","mfTimeDefaults","time","defaultTimeFormats","convertFormatsToIntlMessageFormat","set","formattedMessage","format","length","transformedValues","index","value","chunks","result","isValidElement","cloneElement","prepareTranslationValues","FORMATTING_ERROR","translateFn","rich","raw","resolveNamespace","namespacePrefix","slice","MINUTE","SECOND","HOUR","DAY","WEEK","MONTH","QUARTER","YEAR","UNIT_SECONDS","second","seconds","minute","minutes","hour","hours","day","days","week","weeks","month","months","quarter","quarters","year","years","createFormatter","globalNow","now","globalTimeZone","getFormattedValue","formatOrOptions","typeFormats","formatter","options","MISSING_FORMAT","resolveFormatOrOptions","_options","ENVIRONMENT_FALLBACK","Intl","DateTimeFormat","number","NumberFormat","relativeTime","nowOrOptions","dateDate","Date","nowDate","extractNowDate","getTime","unit","absValue","Math","abs","resolveRelativeTimeUnit","round","calculateRelativeTimeValue","RelativeTimeFormat","numeric","list","ListFormat","createIntl","apply","arguments","formatDateTime","formatNumber","formatRelativeTime","IntlContext","createContext","getInitializedConfig","_objectWithoutPropertiesLoose","_excluded","useIntlContext","context","useContext","getNow","hasWarned","children","useState","Map","React","createElement","Provider","_ref$getMessageFallba","rest","translator","originalRich","base","createTranslatorImpl","_useIntlContext","useMemo","warn","updateInterval","_useState","setNow","useEffect","intervalId","setInterval","clearInterval","allMessages","useTranslationsImpl"],"mappings":"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"}